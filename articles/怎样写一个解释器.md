<div class="inner">
<h2>怎样写一个解释器</h2>
<p>写一个解释器，通常是设计和实现程序语言的第一步。解释器是简单却又深奥的东西，以至于好多人都不会写，所以我决定写一篇这方面的入门读物。</p>
<p>虽然我试图从最基本的原理讲起，尽量不依赖于其它知识，但这并不是一本编程入门教材。我假设你已经理解 Scheme 语言，以及基本的编程技巧（比如递归）。如果你完全不了解这些，那我建议你读一下 <a href="https://mitpress.mit.edu/sicp">SICP</a> 的第一，二章，或者 <a href="http://www.htdp.org">HtDP</a> 的前几章，习题可以不做。注意不要读太多书，否则你就回不来了 ;-) 当然你也可以直接读这篇文章，有不懂的地方再去查资料。</p>
<p>实现语言容易犯的一个错误，就是一开头就试图去实现很复杂的语言（比如 JavaScript 或者 Python）。这样你很快就会因为这些语言的复杂性，以及各种历史遗留的设计问题而受到挫折，最后不了了之。学习实现语言，最好是从最简单，最干净的语言开始，迅速写出一个可用的解释器。之后再逐步往里面添加特性，同时保持正确。这样你才能有条不紊地构造出复杂的解释器。</p>
<p>因为这个原因，这篇文章只针对一个很简单的语言，名叫“R2”。它可以作为一个简单的计算器用，还具有变量定义，函数定义和调用等功能。</p>
<h3 id="我们的工具racket">我们的工具：Racket</h3>
<p>本文的解释器是用 Scheme 语言实现的。Scheme 有很多的“实现”，这里我用的实现叫做 Racket，它可以在这里<a href="http://racket-lang.org">免费下载</a>。为了让程序简洁，我用了一点点 Racket 的模式匹配（pattern matching）功能。我对 Scheme 的实现没有特别的偏好，但 Racket 方便易用，适合教学。如果你用其它的 Scheme 实现，可能得自己做一些调整。</p>
<p>Racket 具有宏（macro），所以它其实可以变成很多种语言。如果你之前用过 DrRacket，那它的“语言设置”可能被你改成了 R5RS 之类的。所以如果下面的程序不能运行，你可能需要检查一下 DrRacket 的“语言设置”，把 Language 设置成 “Racket”。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68562-42a709b7a2e7e422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="" /></p>
<p><img src="http://upload-images.jianshu.io/upload_images/68562-c7da638e83bfb95e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="" /></p>
<p>Racket 允许使用方括号而不只是圆括号，所以你可以写这样的代码：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">x</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="nf">y</span> <span class="mi">2</span><span class="p">])</span>
<span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
</code></pre></div></div>
<p>方括号跟圆括号可以互换，唯一的要求是方括号必须和方括号匹配。通常我喜欢用方括号来表示“无动作”的数据（比如上面的 <code class="language-plaintext highlighter-rouge">[x 1]</code>, <code class="language-plaintext highlighter-rouge">[y 2]</code>），这样可以跟函数调用和其它具有“动作”的代码，产生“视觉差”。这对于代码的可读性是一个改善，因为到处都是圆括号的话，确实有点太单调，容易打瞌睡。</p>
<p>另外，Racket 程序的最上面都需要加上像 <code class="language-plaintext highlighter-rouge">#lang racket</code> 这样的语言选择标记，这样 Racket 才可以知道你想用哪个语言变种。</p>
<h3 id="解释器是什么">解释器是什么</h3>
<p>准备工作就到这里。现在我来谈一下，解释器到底是什么。说白了，解释器跟计算器差不多。解释器是一个函数，你输入一个“表达式”，它就输出一个 “值”，像这样：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68562-573476c0d8151871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="" /></p>
<p>比如，你输入表达式 <code class="language-plaintext highlighter-rouge">'(+ 1 2)</code> ，它就输出值，整数<code class="language-plaintext highlighter-rouge">3</code>。表达式是一种“表象”或者“符号”，而值却更加接近“本质”或者“意义”。我们“解释”了符号，得到它的意义，这也许就是为什么它叫做“解释器”。</p>
<p>需要注意的是，表达式是一个数据结构，而不是一个字符串。我们用一种叫“S 表达式”（S-expression）的结构来存储表达式。比如表达式 <code class="language-plaintext highlighter-rouge">'(+ 1 2)</code> 其实是一个链表（list），它里面的内容是三个符号（symbol）：<code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">1</code> 和 <code class="language-plaintext highlighter-rouge">2</code>，而不是字符串<code class="language-plaintext highlighter-rouge">"(+ 1 2)"</code>。</p>
<p>从 S 表达式这样的“结构化数据”里提取信息，方便又可靠，而从字符串里提取信息，麻烦而且容易出错。Scheme（Lisp）语言里面大量使用结构化数据，少用字符串，这是 Lisp 系统比 Unix 系统先进的地方之一。</p>
<p>从计算理论的角度讲，每个程序都是一台机器的“描述”，而解释器就是在“模拟”这台机器的运转，也就是在进行“计算”。所以从某种意义上讲，解释器就是计算的本质。当然，不同的解释器就会带来不同的计算。</p>
<p>CPU 也是一个解释器，它专门解释执行机器语言。如果你深刻理解了解释器，就可以从本质上看出各种 CPU 的设计为什么是那个样子，它们有什么优缺点，而不只是被动的作为它们的使用者。</p>
<h3 id="抽象语法树abstract-syntax-tree">抽象语法树（Abstract Syntax Tree）</h3>
<p>用 S 表达式所表示的代码，本质上是一种叫做“树”（tree）的数据结构。更具体一点，这叫做“抽象语法树”（Abstract Syntax Tree，简称 AST）。下文为了简洁，我们省略掉“抽象”两个字，就叫它“语法树”。</p>
<p>跟普通的树结构一样，语法树里的节点，要么是一个“叶节点”，要么是一颗“子树”。叶节点是不能再细分的“原子”，比如数字，字符串，操作符，变量名。而子树是可以再细分的“结构”，比如算术表达式，函数定义，函数调用，等等。</p>
<p>举个简单的例子，表达式 <code class="language-plaintext highlighter-rouge">'(* (+ 1 2) (+ 3 4))</code>，就对应如下的语法树结构：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68562-8cedc6f1791d0410.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="" /></p>
<p>其中，<code class="language-plaintext highlighter-rouge">*</code>，两个<code class="language-plaintext highlighter-rouge">+</code>，<code class="language-plaintext highlighter-rouge">1</code>，<code class="language-plaintext highlighter-rouge">2</code>，<code class="language-plaintext highlighter-rouge">3</code>，<code class="language-plaintext highlighter-rouge">4</code> 都是叶节点，而那三个红色节点，都表示子树结构：<code class="language-plaintext highlighter-rouge">'(+ 1 2)</code>，<code class="language-plaintext highlighter-rouge">'(+ 3 4)</code>，<code class="language-plaintext highlighter-rouge">'(* (+ 1 2) (+ 3 4))</code>。</p>
<h3 id="树遍历算法">树遍历算法</h3>
<p>在基础的数据结构课程里，我们都学过二叉树的遍历操作，也就是所谓先序遍历，中序遍历和后序遍历。语法树跟二叉树，其实没有很大区别，所以你也可以在它上面进行遍历。解释器的算法，就是在语法树上的一种遍历操作。由于这个渊源关系，我们先来做一个遍历二叉树的练习。做好了之后，我们就可以把这段代码扩展成一个解释器。</p>
<p>这个练习是这样：写出一个函数，名叫<code class="language-plaintext highlighter-rouge">tree-sum</code>，它对二叉树进行“求和”，把所有节点里的数加在一起，返回它们的和。举个例子，<code class="language-plaintext highlighter-rouge">(tree-sum '((1 2) (3 4)))</code>，执行后应该返回 <code class="language-plaintext highlighter-rouge">10</code>。注意：这是一颗二叉树，所以不会含有长度超过 2 的子树，你不需要考虑像 <code class="language-plaintext highlighter-rouge">((1 2) (3 4 5))</code> 这类情况。需要考虑的例子是像这样：<code class="language-plaintext highlighter-rouge">(1 2)</code>，<code class="language-plaintext highlighter-rouge">(1 (2 3))</code>, <code class="language-plaintext highlighter-rouge">((1 2) 3)</code> <code class="language-plaintext highlighter-rouge">((1 2) (3 4))</code>，……</p>
<p>（为了达到最好的学习效果，你最好试一下写出这个函数再继续往下看。）</p>
<p>好了，希望你得到了跟我差不多的结果。我的代码是这个样子：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span><span class="nv">lang</span> <span class="nv">racket</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">tree-sum</span>
<span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nb">exp</span><span class="p">)</span>
<span class="p">(</span><span class="nf">match</span> <span class="nv">exp</span>                         <span class="c1">; 对输入exp进行模式匹配</span>
<span class="p">[(</span><span class="nf">?</span> <span class="nv">number?</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">]</span>                <span class="c1">; exp是一个数x吗？如果是，那么返回这个数x</span>
<span class="p">[</span><span class="o">`</span><span class="p">(</span><span class="nf">,e1</span> <span class="o">,</span><span class="nv">e2</span><span class="p">)</span>                      <span class="c1">; exp是一个含有两棵子树的中间节点吗？</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">v1</span> <span class="p">(</span><span class="nf">tree-sum</span> <span class="nv">e1</span><span class="p">)]</span>        <span class="c1">; 递归调用tree-sum自己，对左子树e1求值</span>
<span class="p">[</span><span class="nf">v2</span> <span class="p">(</span><span class="nf">tree-sum</span> <span class="nv">e2</span><span class="p">)])</span>       <span class="c1">; 递归调用tree-sum自己，对右子树e2求值</span>
<span class="p">(</span><span class="nb">+</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">))])))</span>                <span class="c1">; 返回左右子树结果v1和v2的和</span>
</code></pre></div></div>
<p>你可以通过以下的例子来测试它的正确性：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">tree-sum</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1">;; =&gt; 3</span>
<span class="p">(</span><span class="nf">tree-sum</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="p">(</span><span class="nf">2</span> <span class="mi">3</span><span class="p">)))</span>
<span class="c1">;; =&gt; 6</span>
<span class="p">(</span><span class="nf">tree-sum</span> <span class="o">'</span><span class="p">((</span><span class="nf">1</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1">;; =&gt; 6</span>
<span class="p">(</span><span class="nf">tree-sum</span> <span class="o">'</span><span class="p">((</span><span class="nf">1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">3</span> <span class="mi">4</span><span class="p">)))</span>
<span class="c1">;; =&gt; 10</span>
</code></pre></div></div>
<p>（完整的代码和示例，可以在<a href="https://github.com/yinwang0/interpreters/blob/master/tree-sum.ss">这里下载</a>。）</p>
<p>这个算法很简单，我们可以把它用文字描述如下：</p>
<ol>
<li>如果输入 <code class="language-plaintext highlighter-rouge">exp</code> 是一个数，那就返回这个数。</li>
<li>否则如果 <code class="language-plaintext highlighter-rouge">exp</code> 是像 <code class="language-plaintext highlighter-rouge">(,e1 ,e2)</code> 这样的子树，那么分别对 <code class="language-plaintext highlighter-rouge">e1</code> 和 <code class="language-plaintext highlighter-rouge">e2</code> 递归调用 <code class="language-plaintext highlighter-rouge">tree-sum</code>，进行求和，得到 <code class="language-plaintext highlighter-rouge">v1</code> 和 <code class="language-plaintext highlighter-rouge">v2</code>，然后返回 <code class="language-plaintext highlighter-rouge">v1 + v2</code> 的和。</li>
</ol>
<p>你自己写出来的代码，也许用了 if 或者 cond 语句来进行分支，而我的代码里面使用的是 Racket 的模式匹配（match）。这个例子用 if 或者 cond 其实也可以，但我之后要把这代码扩展成一个解释器，所以提前使用了 match。这样跟后面的代码对比的时候，就更容易看出规律来。接下来，我就简单讲一下这个 match 表达式的工作原理。</p>
<h3 id="模式匹配">模式匹配</h3>
<p>现在不得不插入一点 Racket 的技术细节，如果你已经学会使用 Racket 的模式匹配，可以跳过这一节。你也可以通过阅读 Racket 模式匹配的<a href="https://docs.racket-lang.org/reference/match.html">文档</a>来代替这一节。但我建议你不要读太多文档，因为我接下去只用到很少的模式匹配功能，我把它们都解释如下。</p>
<p>模式匹配的形式一般是这样：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">match</span> <span class="nv">x</span>
<span class="p">[</span><span class="err">模式</span> <span class="err">结果</span><span class="p">]</span>
<span class="p">[</span><span class="err">模式</span> <span class="err">结果</span><span class="p">]</span>
<span class="o">...</span>   <span class="o">...</span>
<span class="p">)</span>    
</code></pre></div></div>
<p>它先对 <code class="language-plaintext highlighter-rouge">x</code> 求值，然后根据值的结构来进行分支。每个分支由两部分组成，左边是一个模式，右边是一个结果。整个 match 语句的语义是这样：从上到下依次考虑，找到第一个可以匹配 <code class="language-plaintext highlighter-rouge">x</code> 的值的模式，返回它右边的结果。左边的模式在匹配之后，可能会绑定一些变量，这些变量可以在右边的表达式里使用。</p>
<p>模式匹配是一种分支语句，它在逻辑上就是 Scheme（Lisp） 的 <code class="language-plaintext highlighter-rouge">cond</code> 表达式，或者 Java 的嵌套条件语句 <code class="language-plaintext highlighter-rouge">if ... else if ... else ...</code>。然而跟条件语句里的“条件”不同，每条 match 语句左边的模式，可以准确而形象地描述数据结构的形状，而且可以在匹配的同时，对结构里的成员进行“绑定”。这样我们可以在右边方便的访问结构成员，而不需要使用访问函数（accessor）或者 <code class="language-plaintext highlighter-rouge">foo.x</code> 这样的属性语法（attribute）。而且模式可以有嵌套的子结构，所以它能够一次性的表示复杂的数据结构。</p>
<p>举个实在点的例子。我的代码里用了这样一个 match 表达式：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">match</span> <span class="nv">exp</span>
<span class="p">[(</span><span class="nf">?</span> <span class="nv">number?</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">]</span>
<span class="p">[</span><span class="o">`</span><span class="p">(</span><span class="nf">,e1</span> <span class="o">,</span><span class="nv">e2</span><span class="p">)</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">v1</span> <span class="p">(</span><span class="nf">tree-sum</span> <span class="nv">e1</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">v2</span> <span class="p">(</span><span class="nf">tree-sum</span> <span class="nv">e2</span><span class="p">)])</span>
<span class="p">(</span><span class="nb">+</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">))])</span>
</code></pre></div></div>
<p>第二行里面的 <code class="language-plaintext highlighter-rouge">'(,e1 ,e2)</code> 是一个模式（pattern），它被用来匹配 <code class="language-plaintext highlighter-rouge">exp</code> 的值。如果 <code class="language-plaintext highlighter-rouge">exp</code> 是 <code class="language-plaintext highlighter-rouge">'(1 2)</code>，那么它与<code class="language-plaintext highlighter-rouge">'(,e1 ,e2)</code>匹配的时候，就会把 <code class="language-plaintext highlighter-rouge">e1</code> 绑定到 <code class="language-plaintext highlighter-rouge">'1</code>，把 <code class="language-plaintext highlighter-rouge">e2</code> 绑定到 <code class="language-plaintext highlighter-rouge">'2</code>。这是因为它们结构相同：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">`</span><span class="p">(</span><span class="nf">,e1</span> <span class="o">,</span><span class="nv">e2</span><span class="p">)</span>
<span class="o">'</span><span class="p">(</span>  <span class="mi">1</span>   <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>
<p>说白了，模式就是一个可以含有“名字”（像 <code class="language-plaintext highlighter-rouge">e1</code> 和 <code class="language-plaintext highlighter-rouge">e2</code>）的结构，像 <code class="language-plaintext highlighter-rouge">'(,e1 ,e2)</code>。我们拿这个带有名字的结构，去匹配实际数据，像 <code class="language-plaintext highlighter-rouge">'(1 2)</code>。当它们一一对应之后，这些名字就被绑定到数据里对应位置的值。</p>
<p>第一行的“模式”比较特殊，<code class="language-plaintext highlighter-rouge">(? number? x)</code> 表示的，其实是一个普通的条件判断，相当于 <code class="language-plaintext highlighter-rouge">(number? exp)</code>，如果这个条件成立，那么它把 <code class="language-plaintext highlighter-rouge">exp</code> 的值绑定到 <code class="language-plaintext highlighter-rouge">x</code>，这样右边就可以用 <code class="language-plaintext highlighter-rouge">x</code> 来指代 <code class="language-plaintext highlighter-rouge">exp</code>。对于无法细分的结构（比如数字，布尔值），你只能用这种方式来“匹配”。看起来有点奇怪，不过习惯了就好了。</p>
<p>模式匹配对解释器和编译器的书写相当有用，因为程序的语法树往往具有嵌套的结构。不用模式匹配的话，往往要写冗长，复杂，不直观的代码，才能描述出期望的结构。而且由于结构的嵌套比较深，很容易漏掉边界情况，造成错误。模式匹配可以直观的描述期望的结构，避免漏掉边界情况，而且可以方便的访问结构成员。</p>
<p>由于这个原因，很多源于 ML 的语言（比如 OCaml，Haskell）都有模式匹配的功能。因为 ML（Meta-Language）原来设计的用途，就是用来实现程序语言的。Racket 的模式匹配也是部分受了 ML 的启发，实际上它们的原理是一模一样的。</p>
<p>好了，树遍历的练习就做到这里。然而这跟解释器有什么关系呢？下面我们只把它改一下，就可以得到一个简单的解释器。</p>
<h3 id="一个计算器">一个计算器</h3>
<p>计算器也是一种解释器，只不过它只能处理算术表达式。我们的下一个目标，就是写出一个计算器。如果你给它 <code class="language-plaintext highlighter-rouge">'(* (+ 1 2) (+ 3 4))</code>，它就输出 <code class="language-plaintext highlighter-rouge">21</code>。可不要小看这个计算器，稍后我们把它稍加改造，就可以得到一个更多功能的解释器。</p>
<p>上面的代码里，我们利用递归遍历，对树里的数字求和。那段代码里，其实已经隐藏了一个解释器的框架。你观察一下，一个算术表达式  <code class="language-plaintext highlighter-rouge">'(* (+ 1 2) (+ 3 4))</code>，跟二叉树 <code class="language-plaintext highlighter-rouge">'((1 2) (3 4))</code> 有什么不同？发现没有，这个算术表达式比起二叉树，只不过在每个子树结构里多出了一个操作符：一个 <code class="language-plaintext highlighter-rouge">*</code> 和两个 <code class="language-plaintext highlighter-rouge">+</code> 。它不再是一棵二叉树，而是一种更通用的树结构。</p>
<p>这点区别，也就带来了二叉树求和与解释器算法的区别。对二叉树进行求和的时候，在每个子树节点，我们都做加法。而对表达式进行解释的时候，在每一个子树节点，我们不一定进行加法。根据子树的“操作符”不同，我们可能会选择加，减，乘，除四种操作。</p>
<p>好了，下面就是这个计算器的代码。它接受一个表达式，输出一个数字作为结果。</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span><span class="nv">lang</span> <span class="nv">racket</span>                                  <span class="c1">; 声明用 Racket 语言</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">calc</span>
<span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nb">exp</span><span class="p">)</span>
<span class="p">(</span><span class="nf">match</span> <span class="nv">exp</span>                                <span class="c1">; 分支匹配：表达式的两种情况</span>
<span class="p">[(</span><span class="nf">?</span> <span class="nv">number?</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">]</span>                       <span class="c1">; 是数字，直接返回</span>
<span class="p">[</span><span class="o">`</span><span class="p">(</span><span class="nf">,op</span> <span class="o">,</span><span class="nv">e1</span> <span class="o">,</span><span class="nv">e2</span><span class="p">)</span>                         <span class="c1">; 匹配提取操作符op和两个操作数e1,e2</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">v1</span> <span class="p">(</span><span class="nf">calc</span> <span class="nv">e1</span><span class="p">)]</span>                   <span class="c1">; 递归调用 calc 自己，得到 e1 的值</span>
<span class="p">[</span><span class="nf">v2</span> <span class="p">(</span><span class="nf">calc</span> <span class="nv">e2</span><span class="p">)])</span>                  <span class="c1">; 递归调用 calc 自己，得到 e2 的值</span>
<span class="p">(</span><span class="nf">match</span> <span class="nv">op</span>                            <span class="c1">; 分支匹配：操作符 op 的 4 种情况</span>
<span class="p">[</span><span class="ss">'+</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)]</span>                     <span class="c1">; 如果是加号，输出结果为 (+ v1 v2)</span>
<span class="p">[</span><span class="ss">'-</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)]</span>                     <span class="c1">; 如果是减号，乘号，除号，相似的处理</span>
<span class="p">[</span><span class="ss">'*</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)]</span>
<span class="p">[</span><span class="ss">'/</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)]))])))</span>
</code></pre></div></div>
<p>你可以得到如下的结果：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">calc</span> <span class="o">'</span><span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1">;; =&gt; 3</span>
<span class="p">(</span><span class="nf">calc</span> <span class="o">'</span><span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1">;; =&gt; 6</span>
<span class="p">(</span><span class="nf">calc</span> <span class="o">'</span><span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)))</span>
<span class="c1">;; =&gt; 21</span>
</code></pre></div></div>
<p>（完整的代码和示例，可以在<a href="https://github.com/yinwang0/interpreters/blob/master/calculator.ss">这里下载</a>。）</p>
<p>跟之前的二叉树求和代码比较一下，你会发现它们惊人的相似，因为解释器本来就是一个树遍历算法。不过你发现它们有什么不同吗？它们的不同点在于：</p>
<ol>
<li>
<p>算术表达式的模式里面，多出了一个“操作符”（op）叶节点：<code class="language-plaintext highlighter-rouge">(,op ,e1 ,e2)</code></p>
</li>
<li>
<p>对子树 e1 和 e2 分别求值之后，我们不是返回 <code class="language-plaintext highlighter-rouge">(+ v1 v2)</code>，而是根据 <code class="language-plaintext highlighter-rouge">op</code> 的不同，返回不同的结果：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">match</span> <span class="nv">op</span>
<span class="p">[</span><span class="ss">'+</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)]</span>
<span class="p">[</span><span class="ss">'-</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)]</span>
<span class="p">[</span><span class="ss">'*</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)]</span>
<span class="p">[</span><span class="ss">'/</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)])</span>
</code></pre></div>    </div>
</li>
</ol>
<p>最后你发现，一个算术表达式的解释器，不过是一个稍加扩展的树遍历算法。</p>
<h3 id="r2一个很小的程序语言">R2：一个很小的程序语言</h3>
<p>实现了一个计算器，现在让我们过渡到一种更强大的语言。为了方便称呼，我给它起了一个萌萌哒名字，叫 R2。R2 比起之前的计算器，只多出四个元素，它们分别是：变量，函数，绑定，调用。再加上之前介绍的算术操作，我们就得到一个很简单的程序语言，它只有5种不同的构造。用 Scheme 的语法，这5种构造看起来就像这样：</p>
<ul>
<li>变量：x</li>
<li>函数：(lambda (x) e)</li>
<li>绑定：(let ([x e1]) e2)</li>
<li>调用：(e1 e2)</li>
<li>算术：(• e2 e2)</li>
</ul>
<p>（其中，• 是一个算术操作符，可以选择 <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">/</code> 其中之一）</p>
<p>一般程序语言还有很多其它构造，可是一开头就试图去实现所有那些，只会让人糊涂。最好是把这少数几个东西搞清楚，确保它们正确之后，才慢慢加入其它元素。</p>
<p>这些构造的语义，跟 Scheme 里面的同名构造几乎一模一样。如果你不清楚什么是”绑定“，那你可以把它看成是普通语言里的”变量声明“。</p>
<p>需要注意的是，跟一般语言不同，我们的函数只接受一个参数。这不是一个严重的限制，因为在我们的语言里，函数可以被作为值传递，也就是所谓“first-class function”。所以你可以用嵌套的函数定义来表示有两个以上参数的函数。</p>
<p>举个例子， <code class="language-plaintext highlighter-rouge">(lambda (x) (lambda (y) (+ x y)))</code> 是个嵌套的函数定义，它也可以被看成是有两个参数（<code class="language-plaintext highlighter-rouge">x</code> 和 <code class="language-plaintext highlighter-rouge">y</code>）的函数，这个函数返回 <code class="language-plaintext highlighter-rouge">x</code> 和 <code class="language-plaintext highlighter-rouge">y</code> 的和。当这样的函数被调用的时候，需要两层调用，就像这样：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
<span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
<span class="mi">1</span><span class="p">)</span>
<span class="mi">2</span><span class="p">)</span>
<span class="c1">;; =&gt; 3</span>
</code></pre></div></div>
<p>这种做法在PL术语里面，叫做咖喱（currying）。看起来啰嗦，但这样我们的解释器可以很简单。等我们理解了基本的解释器，再实现真正的多参数函数也不迟。</p>
<p>另外，我们的绑定语法 <code class="language-plaintext highlighter-rouge">(let ([x e1]) e2)</code>，比起 Scheme 的绑定也有一些局限。我们的 let 只能绑定一个变量，而 Scheme 可以绑定多个，像这样 <code class="language-plaintext highlighter-rouge">(let ([x 1] [y 2]) (+ x y))</code>。这也不是一个严重的限制，因为我们可以啰嗦一点，用嵌套的 let 绑定：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">x</span> <span class="mi">1</span><span class="p">])</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">y</span> <span class="mi">2</span><span class="p">])</span>
<span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
</code></pre></div></div>
<h3 id="r2-的解释器">R2 的解释器</h3>
<p>下面是我们今天要完成的解释器，它可以运行一个 R2 程序。你可以先留意一下各部分的注释。</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span><span class="nv">lang</span> <span class="nv">racket</span>
<span class="c1">;;; 以下三个定义 env0, ext-env, lookup 是对环境（environment）的基本操作：</span>
<span class="c1">;; 空环境</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">env0</span> <span class="o">'</span><span class="p">())</span>
<span class="c1">;; 扩展。对环境 env 进行扩展，把 x 映射到 v，得到一个新的环境</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ext-env</span>
<span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">v</span> <span class="nv">env</span><span class="p">)</span>
<span class="p">(</span><span class="nb">cons</span> <span class="o">`</span><span class="p">(</span><span class="nf">,x</span> <span class="o">.</span> <span class="o">,</span><span class="nv">v</span><span class="p">)</span> <span class="nv">env</span><span class="p">)))</span>
<span class="c1">;; 查找。在环境中 env 中查找 x 的值。如果没找到就返回 #f</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">lookup</span>
<span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">env</span><span class="p">)</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">p</span> <span class="p">(</span><span class="nb">assq</span> <span class="nv">x</span> <span class="nv">env</span><span class="p">)])</span>
<span class="p">(</span><span class="k">cond</span>
<span class="p">[(</span><span class="nb">not</span> <span class="nv">p</span><span class="p">)</span> <span class="no">#f</span><span class="p">]</span>
<span class="p">[</span><span class="k">else</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">p</span><span class="p">)]))))</span>
<span class="c1">;; 闭包的数据结构定义，包含一个函数定义 f 和它定义时所在的环境</span>
<span class="p">(</span><span class="nf">struct</span> <span class="nv">Closure</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">env</span><span class="p">))</span>
<span class="c1">;; 解释器的递归定义（接受两个参数，表达式 exp 和环境 env）</span>
<span class="c1">;; 共 5 种情况（变量，函数，绑定，调用，数字，算术表达式）</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">interp</span>
<span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nb">exp</span> <span class="nv">env</span><span class="p">)</span>
<span class="p">(</span><span class="nf">match</span> <span class="nv">exp</span>                                          <span class="c1">; 对exp进行模式匹配</span>
<span class="p">[(</span><span class="nf">?</span> <span class="nv">symbol?</span> <span class="nv">x</span><span class="p">)</span>                                    <span class="c1">; 变量</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">v</span> <span class="p">(</span><span class="nf">lookup</span> <span class="nv">x</span> <span class="nv">env</span><span class="p">)])</span>
<span class="p">(</span><span class="k">cond</span>
<span class="p">[(</span><span class="nb">not</span> <span class="nv">v</span><span class="p">)</span>
<span class="p">(</span><span class="nf">error</span> <span class="s">"undefined variable"</span> <span class="nv">x</span><span class="p">)]</span>
<span class="p">[</span><span class="k">else</span> <span class="nv">v</span><span class="p">]))]</span>      
<span class="p">[(</span><span class="nf">?</span> <span class="nv">number?</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">]</span>                                 <span class="c1">; 数字</span>
<span class="p">[</span><span class="o">`</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">,x</span><span class="p">)</span> <span class="o">,</span><span class="nv">e</span><span class="p">)</span>                                <span class="c1">; 函数</span>
<span class="p">(</span><span class="nf">Closure</span> <span class="nv">exp</span> <span class="nv">env</span><span class="p">)]</span>
<span class="p">[</span><span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">,x</span> <span class="o">,</span><span class="nv">e1</span><span class="p">])</span> <span class="o">,</span><span class="nv">e2</span><span class="p">)</span>                            <span class="c1">; 绑定</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">v1</span> <span class="p">(</span><span class="nf">interp</span> <span class="nv">e1</span> <span class="nv">env</span><span class="p">)])</span>
<span class="p">(</span><span class="nf">interp</span> <span class="nv">e2</span> <span class="p">(</span><span class="nf">ext-env</span> <span class="nv">x</span> <span class="nv">v1</span> <span class="nv">env</span><span class="p">)))]</span>
<span class="p">[</span><span class="o">`</span><span class="p">(</span><span class="nf">,e1</span> <span class="o">,</span><span class="nv">e2</span><span class="p">)</span>                                       <span class="c1">; 调用</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">v1</span> <span class="p">(</span><span class="nf">interp</span> <span class="nv">e1</span> <span class="nv">env</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">v2</span> <span class="p">(</span><span class="nf">interp</span> <span class="nv">e2</span> <span class="nv">env</span><span class="p">)])</span>
<span class="p">(</span><span class="nf">match</span> <span class="nv">v1</span>
<span class="p">[(</span><span class="nf">Closure</span> <span class="o">`</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">,x</span><span class="p">)</span> <span class="o">,</span><span class="nv">e</span><span class="p">)</span> <span class="nv">env-save</span><span class="p">)</span>
<span class="p">(</span><span class="nf">interp</span> <span class="nv">e</span> <span class="p">(</span><span class="nf">ext-env</span> <span class="nv">x</span> <span class="nv">v2</span> <span class="nv">env-save</span><span class="p">))]))]</span>
<span class="p">[</span><span class="o">`</span><span class="p">(</span><span class="nf">,op</span> <span class="o">,</span><span class="nv">e1</span> <span class="o">,</span><span class="nv">e2</span><span class="p">)</span>                                   <span class="c1">; 算术表达式</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">v1</span> <span class="p">(</span><span class="nf">interp</span> <span class="nv">e1</span> <span class="nv">env</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">v2</span> <span class="p">(</span><span class="nf">interp</span> <span class="nv">e2</span> <span class="nv">env</span><span class="p">)])</span>
<span class="p">(</span><span class="nf">match</span> <span class="nv">op</span>
<span class="p">[</span><span class="ss">'+</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)]</span>
<span class="p">[</span><span class="ss">'-</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)]</span>
<span class="p">[</span><span class="ss">'*</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)]</span>
<span class="p">[</span><span class="ss">'/</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)]))])))</span>
<span class="c1">;; 解释器的“用户界面”函数。它把 interp 包装起来，掩盖第二个参数，初始值为 env0</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">r2</span>
<span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nb">exp</span><span class="p">)</span>
<span class="p">(</span><span class="nf">interp</span> <span class="nv">exp</span> <span class="nv">env0</span><span class="p">)))</span>
</code></pre></div></div>
<p>这里有一些测试例子：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">r2</span> <span class="o">'</span><span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1">;; =&gt; 3</span>
<span class="p">(</span><span class="nf">r2</span> <span class="o">'</span><span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1">;; =&gt; 6</span>
<span class="p">(</span><span class="nf">r2</span> <span class="o">'</span><span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)))</span>
<span class="c1">;; =&gt; 14</span>
<span class="p">(</span><span class="nf">r2</span> <span class="o">'</span><span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)))</span>
<span class="c1">;; =&gt; 21</span>
<span class="p">(</span><span class="nf">r2</span> <span class="o">'</span><span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="nv">x</span><span class="p">))</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1">;; =&gt; 6</span>
<span class="p">(</span><span class="nf">r2</span>
<span class="o">'</span><span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">x</span> <span class="mi">2</span><span class="p">])</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">f</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))])</span>
<span class="p">(</span><span class="nf">f</span> <span class="mi">3</span><span class="p">))))</span>
<span class="c1">;; =&gt; 6</span>
<span class="p">(</span><span class="nf">r2</span>
<span class="o">'</span><span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">x</span> <span class="mi">2</span><span class="p">])</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">f</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))])</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">x</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="nf">f</span> <span class="mi">3</span><span class="p">)))))</span>
<span class="c1">;; =&gt; 6</span>
</code></pre></div></div>
<p>（完整的代码和示例，可以在<a href="https://github.com/yinwang0/interpreters/blob/master/r2-interpreter.ss">这里下载</a>。)</p>
<p>在接下来的几节，我们来仔细看看这个解释器的各个部分。</p>
<h3 id="对基本算术操作的解释">对基本算术操作的解释</h3>
<p>算术操作一般都是程序里最基本的构造，它们不能再被细分为多个步骤，所以我们先来看看对算术操作的处理。以下就是 R2 解释器处理算术的部分，它是 <code class="language-plaintext highlighter-rouge">interp</code> 的最后一个分支。</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">match</span> <span class="nv">exp</span>
<span class="o">...</span> <span class="o">...</span>
<span class="p">[</span><span class="o">`</span><span class="p">(</span><span class="nf">,op</span> <span class="o">,</span><span class="nv">e1</span> <span class="o">,</span><span class="nv">e2</span><span class="p">)</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">v1</span> <span class="p">(</span><span class="nf">interp</span> <span class="nv">e1</span> <span class="nv">env</span><span class="p">)]</span>             <span class="c1">; 递归调用 interp 自己，得到 e1 的值</span>
<span class="p">[</span><span class="nf">v2</span> <span class="p">(</span><span class="nf">interp</span> <span class="nv">e2</span> <span class="nv">env</span><span class="p">)])</span>            <span class="c1">; 递归调用 interp 自己，得到 e2 的值</span>
<span class="p">(</span><span class="nf">match</span> <span class="nv">op</span>                            <span class="c1">; 分支：处理操作符 op 的 4 种情况</span>
<span class="p">[</span><span class="ss">'+</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)]</span>                     <span class="c1">; 如果是加号，输出结果为 (+ v1 v2)</span>
<span class="p">[</span><span class="ss">'-</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)]</span>                     <span class="c1">; 如果是减号，乘号，除号，相似的处理</span>
<span class="p">[</span><span class="ss">'*</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)]</span>
<span class="p">[</span><span class="ss">'/</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">v1</span> <span class="nv">v2</span><span class="p">)]))])</span>
</code></pre></div></div>
<p>你可以看到它几乎跟刚才写的计算器一模一样，不过现在 <code class="language-plaintext highlighter-rouge">interp</code> 的调用多了一个参数 <code class="language-plaintext highlighter-rouge">env</code> 而已。这个 <code class="language-plaintext highlighter-rouge">env</code> 是所谓“环境”，我们下面很快就讲。</p>
<h3 id="对数字的解释">对数字的解释</h3>
<p>对数字的解释很简单，把它们原封不动返回就可以了。</p>
<p><code class="language-plaintext highlighter-rouge">[(? number? x) x]</code></p>
<h3 id="变量和函数">变量和函数</h3>
<p>变量和函数是解释器里最麻烦的部分，所以我们来仔细看看。</p>
<p>变量（variable）的产生，是数学史上的最大突破之一。因为变量可以被绑定到不同的值，从而使函数的实现成为可能。比如数学函数 <code class="language-plaintext highlighter-rouge">f(x) = x * 2</code>，其中 <code class="language-plaintext highlighter-rouge">x</code> 是一个变量，它把输入的值传递到函数体 <code class="language-plaintext highlighter-rouge">x * 2</code> 里面。如果没有变量，函数就不可能实现。</p>
<p>对变量最基本的操作，是对它的“绑定”（binding）和“取值”（evaluate）。什么是绑定呢？拿上面的函数 <code class="language-plaintext highlighter-rouge">f(x)</code> 作为例子。当我们调用 <code class="language-plaintext highlighter-rouge">f(1)</code> 时，函数体里面的 <code class="language-plaintext highlighter-rouge">x</code> 等于 1，所以 <code class="language-plaintext highlighter-rouge">x * 2</code> 的值是 2，而当我们调用 <code class="language-plaintext highlighter-rouge">f(2)</code> 时，函数体里面的 <code class="language-plaintext highlighter-rouge">x</code> 等于 2，所以 <code class="language-plaintext highlighter-rouge">x * 2</code> 的值是 4。这里，两次对 <code class="language-plaintext highlighter-rouge">f</code> 的调用，分别对 <code class="language-plaintext highlighter-rouge">x</code> 进行了两次绑定。第一次 <code class="language-plaintext highlighter-rouge">x</code> 被绑定到了 1，第二次被绑定到了 2。</p>
<p>你可以把“绑定”理解成这样一个动作，就像当你把插头插进电源插座的那一瞬间。插头的插脚就是 <code class="language-plaintext highlighter-rouge">f(x)</code> 里面的那个 <code class="language-plaintext highlighter-rouge">x</code>，而 <code class="language-plaintext highlighter-rouge">x * 2</code> 里面的 <code class="language-plaintext highlighter-rouge">x</code>，则是电线的另外一端。所以当你把插头插进插座，电流就通过这根电线到达另外一端。如果电线导电性能良好，两头的电压应该相等。</p>
<h3 id="环境">环境</h3>
<p>我们的解释器只能一步一步的做事情。比如，当它需要求 <code class="language-plaintext highlighter-rouge">f(1)</code> 的值的时候，它分成两步操作：</p>
<ol>
<li>把 <code class="language-plaintext highlighter-rouge">x</code> 绑定到 1，这样函数体内才能看见这个绑定。</li>
<li>进入 <code class="language-plaintext highlighter-rouge">f</code> 的函数体，对 <code class="language-plaintext highlighter-rouge">x * 2</code> 进行求值。</li>
</ol>
<p>这就像一个人做出这两个动作：</p>
<ol>
<li>把插头插进插座 。</li>
<li>到电线的另外一头，测量它的电压，并且把结果乘以 2。</li>
</ol>
<p>在第一步和第二步之间，我们如何记住 <code class="language-plaintext highlighter-rouge">x</code> 的值呢？通过所谓“环境”！我们用环境记录变量的值，并且把它们传递到变量的“可见区域”。变量的可见区域，用术语说叫做“作用域”（scope）。</p>
<p>在我们的解释器里，用于处理环境的代码如下：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; 空环境</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">env0</span> <span class="o">'</span><span class="p">())</span>
<span class="c1">;; 对环境 env 进行扩展，把 x 映射到 v</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">ext-env</span>
<span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">v</span> <span class="nv">env</span><span class="p">)</span>
<span class="p">(</span><span class="nb">cons</span> <span class="o">`</span><span class="p">(</span><span class="nf">,x</span> <span class="o">.</span> <span class="o">,</span><span class="nv">v</span><span class="p">)</span> <span class="nv">env</span><span class="p">)))</span>
<span class="c1">;; 取值。在环境中 env 中查找 x 的值</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">lookup</span>
<span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">env</span><span class="p">)</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">p</span> <span class="p">(</span><span class="nb">assq</span> <span class="nv">x</span> <span class="nv">env</span><span class="p">)])</span>
<span class="p">(</span><span class="k">cond</span>
<span class="p">[(</span><span class="nb">not</span> <span class="nv">p</span><span class="p">)</span> <span class="no">#f</span><span class="p">]</span>
<span class="p">[</span><span class="k">else</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">p</span><span class="p">)]))))</span>
</code></pre></div></div>
<p>这里我们用一种最简单的数据结构，Scheme 的 association list，来表示环境。Association list 看起来像这个样子：<code class="language-plaintext highlighter-rouge">((x . 1) (y . 2) (z . 5))</code>。它是一个两元组（pair）的链表，左边的元素是 key，右边的元素是 value。写得直观一点就是：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="nf">x</span> <span class="o">.</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="nf">y</span> <span class="o">.</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">z</span> <span class="o">.</span> <span class="mi">5</span><span class="p">))</span>
</code></pre></div></div>
<p>查表操作就是从头到尾搜索，如果左边的 key 是要找的变量，就返回整个 pair。简单吧？效率很低，但是足够完成我们现在的任务。</p>
<p><code class="language-plaintext highlighter-rouge">ext-env</code> 函数扩展一个环境。比如，如果原来的环境 <code class="language-plaintext highlighter-rouge">env1</code> 是 <code class="language-plaintext highlighter-rouge">((y . 2) (x . 1))</code> 那么 <code class="language-plaintext highlighter-rouge">(ext-env x 3 env1)</code>，就会返回 <code class="language-plaintext highlighter-rouge">((x . 3) (y . 2) (x . 1))</code>。也就是把 <code class="language-plaintext highlighter-rouge">(x . 3)</code> 加到 <code class="language-plaintext highlighter-rouge">env1</code> 的最前面去。</p>
<p>那我们什么时候需要扩展环境呢？当我们进行绑定的时候。绑定可能出现在函数调用时，也可能出现在 let 绑定时。我们选择的数据结构，使得环境自然而然的具有了作用域（scope）的特性。</p>
<p>环境其实是一个堆栈（stack）。内层的绑定，会出现在环境的最上面，这就是在“压栈”。这样我们查找变量的时候，会优先找到最内层定义的变量。</p>
<p>举个例子：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">x</span> <span class="mi">1</span><span class="p">])</span>         <span class="c1">; env='()。绑定x到1。</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">y</span> <span class="mi">2</span><span class="p">])</span>       <span class="c1">; env='((x . 1))。绑定y到2。</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">x</span> <span class="mi">3</span><span class="p">])</span>     <span class="c1">; env='((y . 2) (x . 1))。绑定x到3。</span>
<span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))))</span>     <span class="c1">; env='((x . 3) (y . 2) (x . 1))。查找x，得到3；查找y，得到2。</span>
<span class="c1">;; =&gt; 5</span>
</code></pre></div></div>
<p>这段代码会返回5。这是因为最内层的绑定，把 <code class="language-plaintext highlighter-rouge">(x . 3)</code> 放到了环境的最前面，这样查找 <code class="language-plaintext highlighter-rouge">x</code> 的时候，我们首先看到 <code class="language-plaintext highlighter-rouge">(x . 3)</code>，然后就返回值3。之前放进去的 <code class="language-plaintext highlighter-rouge">(x . 1)</code> 仍然存在，但是我们先看到了最上面的那个<code class="language-plaintext highlighter-rouge">(x . 3)</code>，所以它被忽略了。</p>
<p>这并不等于说 <code class="language-plaintext highlighter-rouge">(x . 1)</code> 就可以被改写或者丢弃，因为它仍然是有用的。你只需要看一个稍微不同的例子，就知道这是怎么回事：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">x</span> <span class="mi">1</span><span class="p">])</span>          <span class="c1">; env='()。绑定x到1。</span>
<span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">x</span> <span class="mi">2</span><span class="p">])</span>     <span class="c1">; env='((x . 1))。绑定x到2。</span>
<span class="nv">x</span><span class="p">)</span>             <span class="c1">; env='((x . 2) (x . 1))。查找x，得到2。</span>
<span class="nv">x</span><span class="p">))</span>                <span class="c1">; env='((x . 1))。查找x，得到1。</span>
<span class="c1">;; =&gt; 3               ; 两个不同的x的和，1+2等于3。</span>
</code></pre></div></div>
<p>这个例子会返回3。它是第3行和第4行里面两个 <code class="language-plaintext highlighter-rouge">x</code> 的和。由于第3行的 <code class="language-plaintext highlighter-rouge">x</code> 处于内层 let 里面，那里的环境是 <code class="language-plaintext highlighter-rouge">((x . 2) (x . 1))</code>，所以查找 <code class="language-plaintext highlighter-rouge">x</code> 的值得到2。第4行的 <code class="language-plaintext highlighter-rouge">x</code> 在内层 let 外面，但是在外层 let 里面，那里的环境是 <code class="language-plaintext highlighter-rouge">((x . 1))</code>，所以查找 <code class="language-plaintext highlighter-rouge">x</code> 的值得到1。这很符合直觉，因为 <code class="language-plaintext highlighter-rouge">x</code> 总是找到最内层的定义。</p>
<p>值得注意的是，环境被扩展以后，形成了一个新的环境，而原来的环境并没有被改变。比如，上面的 <code class="language-plaintext highlighter-rouge">((y . 2) (x . 1))</code> 并没有删除或者修改，只不过是被“引用”到一个更大的列表里去了。</p>
<p>这样不对已有数据进行修改（mutation）的数据结构，叫做“函数式数据结构”。函数式数据结构只生成新的数据，而不改变或者删除老的。它可能引用老的结构，然而却不改变老的结构。这种“不修改”（immutable）的性质，在我们的解释器里是很重要的，因为当我们扩展一个环境，进入递归，返回之后，外层的代码必须仍然可以访问原来外层的环境。</p>
<p>当然，我们也可以用另外的，更高效的数据结构（比如平衡树，串接起来的哈希表）来表示环境。如果你学究一点，甚至可以用函数来表示环境。这里为了代码简单，我们选择了最笨，然而正确，容易理解的数据结构。</p>
<h3 id="对变量的解释">对变量的解释</h3>
<p>了解了变量，函数和环境，我们来看看解释器对变量的“取值”操作，也就是 <code class="language-plaintext highlighter-rouge">match</code> 的第一种情况。</p>
<p><code class="language-plaintext highlighter-rouge">[(? symbol? x) (lookup x env)]</code></p>
<p>这就是在环境中，沿着从内向外的“作用域顺序”，查找变量的值。</p>
<p>这里的 <code class="language-plaintext highlighter-rouge">(? symbol? x)</code> 是一种特殊的模式，它使用 Scheme 函数 <code class="language-plaintext highlighter-rouge">symbol?</code> 来判断输入是否是一个符号，如果是，就把它绑定到 <code class="language-plaintext highlighter-rouge">x</code>，然后你就可以在右边用 <code class="language-plaintext highlighter-rouge">x</code> 来指称这个输入。</p>
<h3 id="对绑定的解释">对绑定的解释</h3>
<p>现在我们来看看对 let 绑定的解释：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="o">`</span><span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">,x</span> <span class="o">,</span><span class="nv">e1</span><span class="p">])</span> <span class="o">,</span><span class="nv">e2</span><span class="p">)</span>                           
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">v1</span> <span class="p">(</span><span class="nf">interp</span> <span class="nv">e1</span> <span class="nv">env</span><span class="p">)])</span>              <span class="c1">; 解释右边表达式e1，得到值v1</span>
<span class="p">(</span><span class="nf">interp</span> <span class="nv">e2</span> <span class="p">(</span><span class="nf">ext-env</span> <span class="nv">x</span> <span class="nv">v1</span> <span class="nv">env</span><span class="p">)))]</span>       <span class="c1">; 把(x . v1)扩充到环境顶部，对e2求值</span>
</code></pre></div></div>
<p>通过代码里的注释，你也许已经可以理解它在做什么。我们先对表达式 <code class="language-plaintext highlighter-rouge">e1</code> 求值，得到 <code class="language-plaintext highlighter-rouge">v1</code>。然后我们把 <code class="language-plaintext highlighter-rouge">(x . v1)</code> 扩充到环境里，这样 <code class="language-plaintext highlighter-rouge">(let ([x e1]) ...)</code> 内部都可以看到 <code class="language-plaintext highlighter-rouge">x</code> 的值。然后我们使用这个扩充后的环境，递归调用解释器本身，对 let 的主体 <code class="language-plaintext highlighter-rouge">e2</code> 求值。它的返回值就是这个 let 绑定的值。</p>
<h3 id="lexical-scoping-和-dynamic-scoping">Lexical Scoping 和 Dynamic Scoping</h3>
<p>下面我们准备谈谈函数定义和调用。对函数的解释是一个微妙的问题，很容易弄错，这是由于函数体内也许会含有外层的变量，叫做“自由变量”。所以在分析函数的代码之前，我们来了解一下不同的“作用域”（scoping）规则。</p>
<p>我们举个例子来解释这个问题。下面这段代码，它的值应该是多少呢？</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">x</span> <span class="mi">2</span><span class="p">])</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">f</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))])</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">x</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="nf">f</span> <span class="mi">3</span><span class="p">))))</span>
</code></pre></div></div>
<p>在这里，<code class="language-plaintext highlighter-rouge">f</code> 函数体 <code class="language-plaintext highlighter-rouge">(lambda (y) (* x y))</code> 里的那个 <code class="language-plaintext highlighter-rouge">x</code>，就是一个“自由变量”。<code class="language-plaintext highlighter-rouge">x</code> 并不是这个函数的参数，也不是在这个函数里面定义的，所以我们必须到函数外面去找 <code class="language-plaintext highlighter-rouge">x</code> 的值。</p>
<p>我们的代码里面，有两个地方对 <code class="language-plaintext highlighter-rouge">x</code> 进行了绑定，一个等于2，一个等于4，那么 <code class="language-plaintext highlighter-rouge">x</code> 到底应该是指向哪一个绑定呢？这似乎无关痛痒，然而当我们调用 <code class="language-plaintext highlighter-rouge">(f 3)</code> 的时候，严重的问题来了。<code class="language-plaintext highlighter-rouge">f</code> 的函数体是 <code class="language-plaintext highlighter-rouge">(* x y)</code>，我们知道 <code class="language-plaintext highlighter-rouge">y</code> 的值来自参数 3，可是 <code class="language-plaintext highlighter-rouge">x</code> 的值是多少呢？它应该是2，还是4呢？</p>
<p>在历史上，这段代码可能有两种不同的结果，这种区别一直延续到今天。如果你在 Scheme （Racket）里面写以上的代码，它的结果是6。</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Scheme</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">x</span> <span class="mi">2</span><span class="p">])</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">f</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))])</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">x</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="nf">f</span> <span class="mi">3</span><span class="p">))))</span>
<span class="c1">;; =&gt; 6</span>
</code></pre></div></div>
<p>现在我们来看看，在 Emacs Lisp 里面输入等价的代码，得到什么结果。如果你不熟悉 Emacs Lisp 的用法，那你可以跟我做：把代码输入 Emacs 的那个叫 <code class="language-plaintext highlighter-rouge">*scratch*</code> 的 buffer。把光标放在代码最后，然后按 C-x C-e，这样 Emacs 会执行这段代码，然后在 minibuffer 里显示结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68562-ba6ffcfc96ef6f9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="" /></p>
<p>结果是12！如果你把代码最内层的 <code class="language-plaintext highlighter-rouge">x</code> 绑定修成其它的值，输出会随之改变。</p>
<p>奇怪吧？Scheme 和 Emacs Lisp，到底有什么不一样呢？实际上，这两种看似差不多的 “Lisp 方言”，采用了两种完全不同的作用域方式。Scheme 的方式叫做 lexical scoping （或者 static scoping），而 Emacs 的方式叫做 dynamic scoping。</p>
<p>那么哪一种方式更好呢？或者用哪一种都无所谓？答案是，dynamic scoping 是非常错误的做法。历史的教训告诉我们，它会带来许许多多莫名其妙的 bug，导致 dynamic scoping 的语言几乎完全没法用。这是为什么呢？</p>
<p>原因在于，像 <code class="language-plaintext highlighter-rouge">(let ((x 4)) …)</code> 这样的变量绑定，只应该影响它内部“看得见”的 <code class="language-plaintext highlighter-rouge">x</code> 的值。当我们看见  <code class="language-plaintext highlighter-rouge">(let ((x 4)) (f 3))</code> 的时候，并没有在 let 的内部看见任何叫“x” 的变量，所以我们“直觉”的认为，<code class="language-plaintext highlighter-rouge">(let ((x 4)) …)</code> 对 <code class="language-plaintext highlighter-rouge">x</code> 的绑定，不应该引起 <code class="language-plaintext highlighter-rouge">(f 3)</code> 的结果变化。</p>
<p>然而对于 dynamic scoping，我们的直觉却是错误的。因为 <code class="language-plaintext highlighter-rouge">f</code> 的函数体里面有一个 <code class="language-plaintext highlighter-rouge">x</code>，虽然我们没有在 <code class="language-plaintext highlighter-rouge">(f 3)</code> 这个调用里面看见它，然而它却存在于 <code class="language-plaintext highlighter-rouge">f</code> 定义的地方。要知道，<code class="language-plaintext highlighter-rouge">f</code> 定义的地方也许隔着几百行代码，甚至在另外一个文件里面。而且调用函数的人凭什么应该知道， <code class="language-plaintext highlighter-rouge">f</code> 的定义里面有一个自由变量，它的名字叫做 <code class="language-plaintext highlighter-rouge">x</code>？所以 dynamic scoping 在设计学的角度来看，是一个反人类的设计 :)</p>
<p>相反，lexical scoping 却是符合人们直觉的。虽然在 <code class="language-plaintext highlighter-rouge">(let ((x 4)) (f 3))</code> 里面，我们把 <code class="language-plaintext highlighter-rouge">x</code> 绑定到了 4，然而 <code class="language-plaintext highlighter-rouge">f</code> 的函数体并不是在那里定义的，我们也没在那里看见任何 <code class="language-plaintext highlighter-rouge">x</code>，所以 <code class="language-plaintext highlighter-rouge">f</code> 的函数体里面的 <code class="language-plaintext highlighter-rouge">x</code>，仍然指向我们定义它的时候看得见的那个 <code class="language-plaintext highlighter-rouge">x</code>，也就是最上面的那个 <code class="language-plaintext highlighter-rouge">(let ([x 2]) ...)</code>，它的值是 2。所以 <code class="language-plaintext highlighter-rouge">(f 3)</code> 的值应该等于 6，而不是12。</p>
<h3 id="对函数的解释">对函数的解释</h3>
<p>为了实现 lexical scoping，我们必须把函数做成“闭包”（closure）。闭包是一种特殊的数据结构，它由两个元素组成：函数的定义和当前的环境。我们把闭包定义为一个 Racket 的 struct 结构：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">struct</span> <span class="nv">Closure</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">env</span><span class="p">))</span>
</code></pre></div></div>
<p>有了这个数据结构，我们对 <code class="language-plaintext highlighter-rouge">(lambda (x) e)</code> 的解释就可以写成这样：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="o">`</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">,x</span><span class="p">)</span> <span class="o">,</span><span class="nv">e</span><span class="p">)</span>
<span class="p">(</span><span class="nf">Closure</span> <span class="nv">exp</span> <span class="nv">env</span><span class="p">)]</span>
</code></pre></div></div>
<p>注意这里的 <code class="language-plaintext highlighter-rouge">exp</code> 就是 ``(lambda (,x) ,e)` 自己。</p>
<p>有意思的是，我们的解释器遇到  <code class="language-plaintext highlighter-rouge">(lambda (x) e)</code>，几乎没有做任何计算。它只是把这个函数包装了一下，把它与当前的环境一起，打包放到一个数据结构（Closure）里面。这个闭包结构，记录了我们在函数定义的位置“看得见”的那个环境。稍候在调用的时候，我们就能从这个闭包的环境里面，得到函数体内的自由变量的值。</p>
<h3 id="对调用的解释">对调用的解释</h3>
<p>好了，我们终于到了最后的关头，函数调用。为了直观，我们把函数调用的代码拷贝如下：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="o">`</span><span class="p">(</span><span class="nf">,e1</span> <span class="o">,</span><span class="nv">e2</span><span class="p">)</span>                                            
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">v1</span> <span class="p">(</span><span class="nf">interp</span> <span class="nv">e1</span> <span class="nv">env</span><span class="p">)]</span>             <span class="c1">; 计算函数 e1 的值</span>
<span class="p">[</span><span class="nf">v2</span> <span class="p">(</span><span class="nf">interp</span> <span class="nv">e2</span> <span class="nv">env</span><span class="p">)])</span>            <span class="c1">; 计算参数 e2 的值</span>
<span class="p">(</span><span class="nf">match</span> <span class="nv">v1</span>
<span class="p">[(</span><span class="nf">Closure</span> <span class="o">`</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">,x</span><span class="p">)</span> <span class="o">,</span><span class="nv">e</span><span class="p">)</span> <span class="nv">env-save</span><span class="p">)</span>      <span class="c1">; 用模式匹配的方式取出闭包里的各个子结构</span>
<span class="p">(</span><span class="nf">interp</span> <span class="nv">e</span> <span class="p">(</span><span class="nf">ext-env</span> <span class="nv">x</span> <span class="nv">v2</span> <span class="nv">env-save</span><span class="p">))]))]</span>    <span class="c1">; 在闭包的环境env-save中把x绑定到v2，解释函数体     </span>
</code></pre></div></div>
<p>函数调用都是 <code class="language-plaintext highlighter-rouge">(e1 e2)</code> 这样的形式，<code class="language-plaintext highlighter-rouge">e1</code> 表示函数，<code class="language-plaintext highlighter-rouge">e2</code> 是它的参数。我们需要先分别求出函数 <code class="language-plaintext highlighter-rouge">e1</code> 和参数 <code class="language-plaintext highlighter-rouge">e2</code> 的值。</p>
<p>函数调用就像把一个电器的插头插进插座，使它开始运转。比如，当 <code class="language-plaintext highlighter-rouge">(lambda (x) (* x 2))</code> 被作用于 1 时，我们把 <code class="language-plaintext highlighter-rouge">x</code> 绑定到 1，然后解释它的函数体 <code class="language-plaintext highlighter-rouge">(* x 2)</code>。但是这里有一个问题，函数体内的自由变量应该取什么值呢？从上面闭包的讨论，你已经知道了，自由变量的值，应该从闭包的环境查询。</p>
<p>操作数 <code class="language-plaintext highlighter-rouge">e1</code> 的值 <code class="language-plaintext highlighter-rouge">v1</code> 是一个闭包，它里面包含一个函数定义时保存的环境 <code class="language-plaintext highlighter-rouge">env-save</code>。我们把这个环境 <code class="language-plaintext highlighter-rouge">env-save</code> 取出来，那我们就可以查询它，得到函数体内自由变量的值。然而函数体内不仅有自由变量，还有对函数参数的使用，所以我们必须扩展这个 <code class="language-plaintext highlighter-rouge">env-save</code> 环境，把参数的值加进去。这就是为什么我们使用 <code class="language-plaintext highlighter-rouge">(ext-env x v2 env-save)</code>，而不只是 <code class="language-plaintext highlighter-rouge">env-save</code>。</p>
<p>你可能会奇怪，那么解释器的环境 <code class="language-plaintext highlighter-rouge">env</code> 难道这里就不用了吗？是的。我们通过 <code class="language-plaintext highlighter-rouge">env</code> 来计算 <code class="language-plaintext highlighter-rouge">e1</code> 和 <code class="language-plaintext highlighter-rouge">e2</code> 的值，是因为 <code class="language-plaintext highlighter-rouge">e1</code> 和 <code class="language-plaintext highlighter-rouge">e2</code> 里面的变量，在“当前环境”（env）里面看得见。可是函数体的定义，在当前环境下是看不见的。它的代码在别的地方，而那个地方看得见的环境，被我们存在闭包里了，它就是 <code class="language-plaintext highlighter-rouge">env-save</code>。所以我们把 <code class="language-plaintext highlighter-rouge">v1</code> 里面的闭包环境 <code class="language-plaintext highlighter-rouge">env-save</code> 取出来，用于计算函数体的值。</p>
<p>有意思的是，如果我们用 <code class="language-plaintext highlighter-rouge">env</code>，而不是<code class="language-plaintext highlighter-rouge">env-save</code> 来解释函数体，那我们的语言就变成了 dynamic scoping。现在来实验一下：你可以把 <code class="language-plaintext highlighter-rouge">(interp e (ext-env x v2 env-save))</code> 里面的 <code class="language-plaintext highlighter-rouge">env-save</code> 改成 <code class="language-plaintext highlighter-rouge">env</code>，再试试我们之前讨论过的代码，它的输出就会变成 12。那就是我们之前讲过的，dynamic scoping 的结果。</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">r2</span>
<span class="o">'</span><span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">x</span> <span class="mi">2</span><span class="p">])</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">f</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))])</span>
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">x</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="nf">f</span> <span class="mi">3</span><span class="p">)))))</span>
<span class="c1">;; =&gt; 12</span>
</code></pre></div></div>
<p>你也许发现了，如果我们的语言是 dynamic scoping，那就没必要使用闭包了，因为我们根本不需要闭包里面保存的环境。这样一来，dynamic scoping 的解释器就可以写成这样：</p>
<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">interp</span>
<span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nb">exp</span> <span class="nv">env</span><span class="p">)</span>
<span class="p">(</span><span class="nf">match</span> <span class="nv">exp</span>                                          
<span class="o">...</span> <span class="o">...</span>
<span class="p">[</span><span class="o">`</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">,x</span><span class="p">)</span> <span class="o">,</span><span class="nv">e</span><span class="p">)</span>                          <span class="c1">; 函数：直接返回自己的表达式</span>
<span class="nv">exp</span><span class="p">]</span>
<span class="o">...</span> <span class="o">...</span>
<span class="p">[</span><span class="o">`</span><span class="p">(</span><span class="nf">,e1</span> <span class="o">,</span><span class="nv">e2</span><span class="p">)</span>                                       
<span class="p">(</span><span class="k">let</span> <span class="p">([</span><span class="nf">v1</span> <span class="p">(</span><span class="nf">interp</span> <span class="nv">e1</span> <span class="nv">env</span><span class="p">)]</span>
<span class="p">[</span><span class="nf">v2</span> <span class="p">(</span><span class="nf">interp</span> <span class="nv">e2</span> <span class="nv">env</span><span class="p">)])</span>
<span class="p">(</span><span class="nf">match</span> <span class="nv">v1</span>
<span class="p">[</span><span class="o">`</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">,x</span><span class="p">)</span> <span class="o">,</span><span class="nv">e</span><span class="p">)</span>                     <span class="c1">; 调用：直接使用函数的表达式本身</span>
<span class="p">(</span><span class="nf">interp</span> <span class="nv">e</span> <span class="p">(</span><span class="nf">ext-env</span> <span class="nv">x</span> <span class="nv">v2</span> <span class="nv">env</span><span class="p">))]))]</span>
<span class="o">...</span> <span class="o">...</span>
<span class="p">)))</span>
</code></pre></div></div>
<p>注意到这个解释器的函数有多容易实现吗？它就是这个函数的表达式自己，原封不动。用函数的表达式本身来表示它的值，是很直接很简单的做法，也是大部分人一开头就会想到的。然而这样实现出来的语言，就不知不觉地采用了 dynamic scoping。</p>
<p>这就是为什么很多早期的 Lisp 语言，比如 Emacs Lisp，都使用 dynamic scoping。这并不是因为它们的设计者在 dynamic scoping 和 lexical scoping 两者之中做出了选择，而是因为使用函数的表达式本身来作为它的值，是最直接，一般人都会首先想到的做法。</p>
<p>另外，在这里我们也看到环境用“函数式数据结构”表示的好处。闭包被调用时它的环境被扩展，但是这并不会影响原来的那个环境，我们得到的是一个新的环境。所以当函数调用返回之后，函数的参数绑定就自动“注销”了。</p>
<p>如果你用一个非函数式的数据结构，在绑定参数时不生成新的环境，而是对已有环境进行赋值，那么这个赋值操作就会永久性的改变原来环境的内容。所以你在函数返回之后必须删除参数的绑定。这样不但麻烦，而且在复杂的情况下很容易出错。</p>
<p><strong>思考题</strong>：可能有些人看过 lambda calculus，这些人可能知道 <code class="language-plaintext highlighter-rouge">(let ([x e1]) e2)</code> 其实等价于一个函数调用：<code class="language-plaintext highlighter-rouge">((lambda (x) e2) e1)</code>。现在问题来了，我们在讨论函数和调用的时候，很深入的讨论了关于 lexical scoping 和 dynamic scoping 的差别。既然 let 绑定等价于一个函数定义和调用，为什么之前我们讨论对绑定的时候，没有讨论过 lexical scoping 和 dynamic scoping 的问题，也没有制造过闭包呢？</p>
<h3 id="不足之处">不足之处</h3>
<p>现在你已经学会了如何写出一个简单的解释器，它可以处理一个相当强大的函数式语言。出于教学的考虑，这个解释器并没有考虑实用的需求，所以它并不能作为工业应用。在这里，我指出它的一些不足之处。</p>
<ol>
<li>
<p>缺少必要的语言构造。我们的语言里缺少好些实用语言必须的构造：递归，数组，赋值操作，字符串，自定义数据结构，…… 作为一篇基础性的读物，我不能把这些都加进来。如果你对这些有兴趣，可以看看其它书籍，或者等待我的后续作品。</p>
</li>
<li>
<p>不合法代码的检测和报告。你也许发现了，这个解释器的 match 表达式，全都假定了输入都是合法的程序，它并没有检查不合法的情况。如果你给它一个不合法的程序，它不会马上报错，而是会真去算它，以至于导致奇怪的后果。一个实用的解释器，必须加入对代码格式进行全面检测，在运行之前就报告不合法的代码结构。</p>
</li>
<li>
<p>低效率的数据结构。在 association list 里面查找变量，是线性的复杂度。当程序有很多变量的时候就有性能问题。一个实用的解释器，需要更高效的数据结构。这种数据结构不一定非得是函数式的。你也可以用非函数式的数据结构（比如哈希表），经过一定的改造，达到同样的性质，却具有更高的效率。
​
另外，你还可以把环境转化成一个数组。给环境里的每个变量分配一个下标（index），在这个数组里就可以找到它的值。如果你用数组表示环境，那么这个解释器就向编译器迈进了一步。</p>
</li>
<li>
<p>S 表达式的歧义问题。为了教学需要，我们的解释器直接使用 S 表达式来表达语法树，用模式匹配来进行分支遍历。在实际的语言里，这种方式会带来比较大的问题。因为 S 表达式是一种通用的数据结构，用它表示的东西，看起来都差不多的样子。一旦程序的语法构造多起来，直接对 S 表达式进行模式匹配，会造成歧义。
​</p>
<p>比如 <code class="language-plaintext highlighter-rouge">(,op ,e1 ,e2)</code> ，你以为它只匹配二元算术操作，比如 <code class="language-plaintext highlighter-rouge">(+ 1 2)</code>。但它其实也可以匹配一个 let 绑定： <code class="language-plaintext highlighter-rouge">(let ([x 1]) (* x 2))</code>。这是因为它们顶层元素的数目是一样的。为了消除歧义，你得小心的安排模式的顺序，比如你必须把 <code class="language-plaintext highlighter-rouge">(let ([,x ,e1]) ,e2)</code> 的模式放在 <code class="language-plaintext highlighter-rouge">(,op ,e1, e2)</code> 前面。所以最好的办法，是不要直接在 S 表达式上写解释器，而是先写一个“parser”，这个 parser 把 S 表达式转换成 Racket 的 struct 结构。然后解释器再在 struct 上面进行分支匹配。这样解释器不用担心歧义问题，而且会带来效率的提升。</p>
</li>
</ol>
<h3 id="付费方式">付费方式</h3>
<p>如果你喜欢这篇文章，可以到这里<a href="http://www.yinwang.org/blog-cn/2016/04/13/pay-blog">付费购买</a>。</p>
</div>
<!--
<div class="ad-banner" style="margin-top: 5px">
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
                    style="display:inline-block;width:100%;height:90px"
                    data-ad-client="ca-pub-1331524016319584"
                    data-ad-slot="6657867155"></ins>
<script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
</div>
<script data-ad-client="ca-pub-1331524016319584" async
            src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
</script>
        -->
    